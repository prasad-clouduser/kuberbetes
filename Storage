
How exactly does docker stores the files of an image and a container? 

Image layer --> read only 
                only can be modified by rebuilding the image. 

container Layer: docker creates a container based off these layers and create a new writable layer on top of the image layer. 
                 used to store the data created by container such as log file written by applications, any temp files generated by container. 
                 or just any file modified by the user on that container. 
                 life as long as container is alive. 

if we change app.py in read layer, docker automatically takes the copy of this file to read write layer. Image layer shared by other runnig containers also 
All future changes happens on this copied app.py file. (in read write layer). this is called copy on write mechanism. 

to persist the container layer you need to create a docker volume. 

when docker volume is created, it creates the volume in the /var/lib/docker/volumes/
                                                                               -- data_volume   
docker run  -v data_volume:/var/lib/mysql mysql  --> creates container and mounts the data volume we created inside the container. 
all the data written by database is infact stored in the data volume created on docker.
The above is called volume mounting. 

if you mount to any /data directory in another server, this is called bind mounting. 

Two types of mounts: 
volume mount mounts the volume from volume directory. 
bind mount mounts a directory from any location on the docker host. 

storage drivers are responsible for all of this operations (maintaing layer arch. creating a writable layer, moving file across the layers to copy on write etc) 
the selection storage driver depends on underlying OS being used. 
for ex: ubunu uses AUFS, which currently unavailable on CENTOS where we need to use device mapper. 

===========================================================================================================================================================================

volumes are handled by volume driver plugins. 
The default volume driver plugin is Local. 
The local volume plugin helps create a volume on the docker host and store its data under the /var/lib/docker/volumes directory 
Many volume driver plugin availbel that allow you to create a volume on third party solutions. 

===========================================================================================================================================================================

Container Storage Interface: 

previoulsy docker alone used as the container runtime engine. and all the code that work with docker was embeded within k8s source code. 
with other container runtimes coming in, such as Rocket or CRI-O it was imp to open up and extend support to work with diff container runtimes and not be dependent 
on the k8s source code. 

CRI is standard that defines how an orchestration solution like k8s would communicate with container runtime like docker. 
any new container runtime would follow CRI standards, that new containre run times would work with k8s 

CSI -> with CSI now you can write your own drivers for your own storage to work with k8s. not a k8s specific standard. 
its meant to be universal standard. and if implemented allows any container archestration tool to work with any storage vendor with a supported plugin. 

CSI kind of looks like below: 
it defines a set of RPCs that will be called by container orchestrator and these must be implemented by storage driver. 

for ex, csi says: when a pod is created and requires a volume, the container orchestrator, in this case k8s should call the create volume RPC and pass a set of details 
such as volume name. The storage driver should implement this RPC and handle that request and provision a new volume on the storage array and return the results of operations. 
same thing for delete volume. 














